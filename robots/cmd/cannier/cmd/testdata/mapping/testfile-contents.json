{"tests/decorators/decorators.go":"package decorators\n\nimport . \"github.com/onsi/ginkgo/v2\"\n\nvar (\n\tQuarantine = Label(\"QUARANTINE\")\n\n\t// Periodic marks tests that must run on periodic lanes only\n\t// See https://github.com/kubevirt/kubevirt/pull/12594\n\tPeriodic    = Label(\"PERIODIC\")\n\tConformance = Label(\"conformance\")\n\n\t// SIGs\n\tSigCompute           = Label(\"sig-compute\")\n\tSigOperator          = Label(\"sig-operator\")\n\tSigNetwork           = Label(\"sig-network\")\n\tSigStorage           = Label(\"sig-storage\")\n\tSigComputeRealtime   = Label(\"sig-compute-realtime\")\n\tSigComputeMigrations = Label(\"sig-compute-migrations\")\n\tSigMonitoring        = Label(\"sig-monitoring\")\n\tSigPerformance       = Label(\"sig-performance\")\n\n\t// HW\n\tGPU         = Label(\"GPU\")\n\tVGPU        = Label(\"VGPU\")\n\tSEV         = Label(\"SEV\")\n\tSEVES       = Label(\"SEVES\")\n\tSRIOV       = Label(\"SRIOV\")\n\tStorageReq  = Label(\"storage-req\")\n\tMultus      = Label(\"Multus\")\n\tMacvtap     = Label(\"Macvtap\")\n\tInvtsc      = Label(\"Invtsc\")\n\tKSMRequired = Label(\"KSM-required\")\n\tACPI        = Label(\"ACPI\")\n\n\t// Deployment\n\tSingleReplica = Label(\"single-replica\")\n\tMultiReplica  = Label(\"multi-replica\")\n\n\t// Features\n\tCPUModel                             = Label(\"cpumodel\")\n\tVSOCK                                = Label(\"vsock\")\n\tVirtioFS                             = Label(\"virtiofs\")\n\tSoftwareEmulation                    = Label(\"software-emulation\")\n\tSysprep                              = Label(\"Sysprep\")\n\tWindows                              = Label(\"Windows\")\n\tNetworking                           = Label(\"Networking\")\n\tVMIlifecycle                         = Label(\"VMIlifecycle\")\n\tExpose                               = Label(\"Expose\")\n\tNativeSSH                            = Label(\"native-ssh\")\n\tExcludeNativeSSH                     = Label(\"exclude-native-ssh\")\n\tReenlightenment                      = Label(\"Reenlightenment\")\n\tTscFrequencies                       = Label(\"TscFrequencies\")\n\tHostDiskGate                         = Label(\"HostDiskGate\")\n\tVMX                                  = Label(\"VMX\")\n\tUpgrade                              = Label(\"Upgrade\")\n\tIstio                                = Label(\"Istio\")\n\tInPlaceHotplugNICs                   = Label(\"in-place-hotplug-NICs\")\n\tMigrationBasedHotplugNICs            = Label(\"migration-based-hotplug-NICs\")\n\tNetCustomBindingPlugins              = Label(\"netCustomBindingPlugins\")\n\tRequiresTwoSchedulableNodes          = Label(\"requires-two-schedulable-nodes\")\n\tVMLiveUpdateRolloutStrategy          = Label(\"VMLiveUpdateRolloutStrategy\")\n\tUSB                                  = Label(\"USB\")\n\tRequiresTwoWorkerNodesWithCPUManager = Label(\"requires-two-worker-nodes-with-cpu-manager\")\n\tRequiresNodeWithCPUManager           = Label(\"requires-node-with-cpu-manager\")\n\tRequiresDualStackCluster             = Label(\"requires-dual-stack-cluster\")\n\tRequiresHugepages2Mi                 = Label(\"requireHugepages2Mi\")\n\tRequiresHugepages1Gi                 = Label(\"requireHugepages1Gi\")\n\n\t// Storage classes\n\t// Requires a storage class with support for snapshots\n\tRequiresSnapshotStorageClass = Label(\"RequiresSnapshotStorageClass\")\n\t// Requires a storage class without support for snapshots\n\tRequiresNoSnapshotStorageClass = Label(\"RequiresNoSnapshotStorageClass\")\n\t// Requires a storage class with ReadWriteMany Block support\n\tRequiresRWXBlock = Label(\"RequiresRWXBlock\")\n\t// Requires the VMStateStorageClass to be set to ReadWriteOnce Filesystem storage class\n\tRequiresRWOFsVMStateStorageClass = Label(\"RequiresRWOFsVMStateStorageClass\")\n\t// Requires the VMStateStorageClass to be set to ReadWriteMany Filesystem storage class\n\tRequiresRWXFsVMStateStorageClass = Label(\"RequiresRWXFsVMStateStorageClass\")\n\n\t// Requires a storage class with Block storage support\n\tRequiresBlockStorage = Label(\"RequiresBlockStorage\")\n\t// Tests that ensure sig-storage functionality which are conformance-unready\n\tStorageCritical = Label(\"StorageCritical\")\n\t// Requires a storage class with volume expansion support\n\tRequiresVolumeExpansion = Label(\"RequiresVolumeExpansion\")\n\t// Kubernetes versions\n\tKubernetes130 = Label(\"kubernetes130\")\n\t// WG archs\n\tWgS390x = Label(\"wg-s390x\")\n\tWgArm64 = Label(\"wg-arm64\")\n\t// Virtctl related tests\n\tVirtctl = Label(\"virtctl\")\n\n\t// NoFlakeChecker decorates tests that are not compatible with the check-tests-for-flakes test lane.\n\t// This should only be used for legitimate purposes, like on tests that have a flake-checker-friendly clone.\n\tNoFlakeCheck = Label(\"no-flake-check\")\n)\n","tests/guestlog/guestlog.go":"package guestlog\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\texpect \"github.com/google/goexpect\"\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\tk8sv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/api/resource\"\n\n\tv1 \"kubevirt.io/api/core/v1\"\n\n\t\"kubevirt.io/kubevirt/pkg/libvmi\"\n\t\"kubevirt.io/kubevirt/pkg/pointer\"\n\t\"kubevirt.io/kubevirt/tests/console\"\n\t\"kubevirt.io/kubevirt/tests/decorators\"\n\t\"kubevirt.io/kubevirt/tests/exec\"\n\t\"kubevirt.io/kubevirt/tests/framework/kubevirt\"\n\t\"kubevirt.io/kubevirt/tests/framework/matcher\"\n\t\"kubevirt.io/kubevirt/tests/libpod\"\n\t\"kubevirt.io/kubevirt/tests/libvmifact\"\n\t\"kubevirt.io/kubevirt/tests/libvmops\"\n\t\"kubevirt.io/kubevirt/tests/testsuite\"\n)\n\nconst cirrosStartupTimeout = 60\nconst testString = \"GuestConsoleTest3413254123535234523\"\n\nvar _ = Describe(\"[sig-compute]Guest console log\", decorators.SigCompute, func() {\n\n\tvar (\n\t\tcirrosVmi *v1.VirtualMachineInstance\n\t)\n\n\tBeforeEach(func() {\n\t\tcirrosVmi = libvmifact.NewCirros(libvmi.WithLogSerialConsole(true))\n\t\tcirrosVmi.Spec.Domain.Devices.AutoattachSerialConsole = pointer.P(true)\n\t})\n\n\tDescribe(\"[level:component] Guest console log container\", func() {\n\t\tContext(\"set LogSerialConsole\", func() {\n\t\t\tIt(\"it should exit cleanly when the shutdown is initiated by the guest\", func() {\n\t\t\t\tBy(\"Starting a VMI\")\n\t\t\t\tvmi := libvmops.RunVMIAndExpectLaunch(cirrosVmi, cirrosStartupTimeout)\n\n\t\t\t\tBy(\"Finding virt-launcher pod\")\n\t\t\t\tvirtlauncherPod, err := libpod.GetPodByVirtualMachineInstance(vmi, testsuite.GetTestNamespace(vmi))\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tfoundContainer := false\n\t\t\t\tfor _, container := range virtlauncherPod.Spec.Containers {\n\t\t\t\t\tif container.Name == \"guest-console-log\" {\n\t\t\t\t\t\tfoundContainer = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tExpect(foundContainer).To(BeTrue())\n\n\t\t\t\tBy(\"Triggering a shutdown from the guest OS\")\n\t\t\t\tExpect(console.LoginToCirros(vmi)).To(Succeed())\n\t\t\t\tExpect(console.SafeExpectBatch(vmi, []expect.Batcher{\n\t\t\t\t\t\u0026expect.BSnd{S: \"sudo poweroff\\n\"},\n\t\t\t\t\t\u0026expect.BExp{R: \"The system is going down NOW!\"},\n\t\t\t\t}, 240)).To(Succeed())\n\n\t\t\t\tBy(\"Ensuring virt-launcher pod is not reporting errors\")\n\t\t\t\tEventually(func(g Gomega) {\n\t\t\t\t\tvirtlauncherPod, err := matcher.ThisPod(virtlauncherPod)()\n\t\t\t\t\tg.Expect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(virtlauncherPod).ToNot(matcher.BeInPhase(k8sv1.PodFailed))\n\t\t\t\t\tg.Expect(virtlauncherPod).To(matcher.BeInPhase(k8sv1.PodSucceeded))\n\t\t\t\t}, 60*time.Second, 1*time.Second).Should(Succeed(), \"virt-launcher should reach the PodSucceeded phase never hitting the PodFailed one\")\n\t\t\t})\n\n\t\t})\n\n\t\tContext(\"fetch logs\", func() {\n\t\t\tvar vmi *v1.VirtualMachineInstance\n\n\t\t\tvar cirrosLogo = `\n  ____               ____  ____\n / __/ __ ____ ____ / __ \\/ __/\n/ /__ / // __// __// /_/ /\\ \\ \n\\___//_//_/  /_/   \\____/___/ \n   http://cirros-cloud.net\n`\n\n\t\t\tIt(\"[QUARANTINE] it should fetch logs for a running VM with logs API\", decorators.Quarantine, func() {\n\t\t\t\tvmi = libvmops.RunVMIAndExpectLaunch(cirrosVmi, cirrosStartupTimeout)\n\n\t\t\t\tBy(\"Finding virt-launcher pod\")\n\t\t\t\tvirtlauncherPod, err := libpod.GetPodByVirtualMachineInstance(vmi, testsuite.GetTestNamespace(vmi))\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tBy(\"Getting logs with logs API and ensure the logs are correctly ordered with no unexpected line breaks\")\n\n\t\t\t\tEventually(func(g Gomega) bool {\n\t\t\t\t\tlogs, err := getConsoleLogs(virtlauncherPod)\n\t\t\t\t\tg.Expect(err).ToNot(HaveOccurred())\n\t\t\t\t\treturn strings.Contains(logs, cirrosLogo)\n\t\t\t\t}, cirrosStartupTimeout*time.Second, 2*time.Second).Should(BeTrue())\n\n\t\t\t\tBy(\"Obtaining the serial console, logging in and executing a command there\")\n\t\t\t\tExpect(console.LoginToCirros(vmi)).To(Succeed())\n\t\t\t\tExpect(console.SafeExpectBatch(vmi, []expect.Batcher{\n\t\t\t\t\t\u0026expect.BSnd{S: \"echo \" + testString + \"\\n\"},\n\t\t\t\t\t\u0026expect.BExp{R: testString},\n\t\t\t\t}, 240)).To(Succeed())\n\n\t\t\t\tBy(\"Ensuring that log fetching is not breaking an open console\")\n\t\t\t\texpecter, errChan, eerr := console.NewExpecter(kubevirt.Client(), vmi, 90*time.Second)\n\t\t\t\tExpect(eerr).ToNot(HaveOccurred())\n\t\t\t\tif eerr == nil {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tderr := expecter.Close()\n\t\t\t\t\t\tExpect(derr).ToNot(HaveOccurred())\n\t\t\t\t\t}()\n\t\t\t\t}\n\n\t\t\t\tConsistently(errChan).ShouldNot(Receive())\n\n\t\t\t\tlogs, err := getConsoleLogs(virtlauncherPod)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tBy(\"Ensuring that logs contain the login attempt\")\n\t\t\t\tExpect(logs).To(ContainSubstring(vmi.Name + \" login: cirros\"))\n\n\t\t\t\t// TODO: console.LoginToCirros is not systematically waiting for `\\u001b[8m` to prevent echoing the password, fix it first\n\t\t\t\t// By(\"Ensuring that logs don't contain the login password\")\n\t\t\t\t// Expect(outputString).ToNot(ContainSubstring(\"Password: gocubsgo\"))\n\n\t\t\t\tBy(\"Ensuring that logs contain the test command and its output\")\n\t\t\t\tExpect(logs).To(ContainSubstring(\"echo \" + testString + \"\\n\"))\n\t\t\t\tExpect(logs).To(ContainSubstring(\"\\n\" + testString + \"\\n\"))\n\t\t\t})\n\n\t\t\tIt(\"it should rotate the internal log files\", decorators.Periodic, func() {\n\t\t\t\tvmi = libvmops.RunVMIAndExpectLaunch(cirrosVmi, cirrosStartupTimeout)\n\n\t\t\t\tBy(\"Finding virt-launcher pod\")\n\t\t\t\tvirtlauncherPod, err := libpod.GetPodByVirtualMachineInstance(vmi, testsuite.GetTestNamespace(vmi))\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tBy(\"Generating 9MB of log data to force log rotation and discarding\")\n\t\t\t\tgenerateHugeLogData(vmi, 9)\n\n\t\t\t\tBy(\"Ensuring that log fetching is not failing\")\n\t\t\t\t_, err = getConsoleLogs(virtlauncherPod)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tBy(\"Ensuring that we have 4 rotated log files (+term one)\")\n\t\t\t\toutputString, err := exec.ExecuteCommandOnPod(virtlauncherPod, \"guest-console-log\", []string{\"/bin/ls\", \"-l\", fmt.Sprintf(\"/var/run/kubevirt-private/%v\", vmi.UID)})\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(strings.Count(outputString, \"virt-serial0-log\")).To(Equal(4 + 1))\n\t\t\t})\n\n\t\t\tIt(\"it should not skip any log line even trying to flood the serial console for QOSGuaranteed VMs\", decorators.Periodic, func() {\n\t\t\t\tcirrosVmi.Spec.Domain.Resources = v1.ResourceRequirements{\n\t\t\t\t\tRequests: k8sv1.ResourceList{\n\t\t\t\t\t\tk8sv1.ResourceCPU:    resource.MustParse(\"1000m\"),\n\t\t\t\t\t\tk8sv1.ResourceMemory: resource.MustParse(\"256M\"),\n\t\t\t\t\t},\n\t\t\t\t\tLimits: k8sv1.ResourceList{\n\t\t\t\t\t\tk8sv1.ResourceCPU:    resource.MustParse(\"1000m\"),\n\t\t\t\t\t\tk8sv1.ResourceMemory: resource.MustParse(\"256M\"),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tvmi = libvmops.RunVMIAndExpectLaunch(cirrosVmi, cirrosStartupTimeout)\n\t\t\t\tExpect(vmi.Status.QOSClass).ToNot(BeNil())\n\t\t\t\tExpect(*vmi.Status.QOSClass).To(Equal(k8sv1.PodQOSGuaranteed))\n\n\t\t\t\tBy(\"Finding virt-launcher pod\")\n\t\t\t\tvirtlauncherPod, err := libpod.GetPodByVirtualMachineInstance(vmi, testsuite.GetTestNamespace(vmi))\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tBy(\"Generating 1MB of log data\")\n\t\t\t\tgenerateHugeLogData(vmi, 1)\n\n\t\t\t\tBy(\"Ensuring that log fetching is not failing\")\n\t\t\t\tlogs, err := getConsoleLogs(virtlauncherPod)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tBy(\"Checking that log lines are sequential with no gaps\")\n\t\t\t\toutputLines := strings.Split(logs, \"\\n\")\n\t\t\t\tExpect(len(outputLines)).To(BeNumerically(\"\u003e\", 1000))\n\t\t\t\tmatchingLines := 0\n\t\t\t\tprevSeqn := -1\n\t\t\t\tprevLine := \"\"\n\t\t\t\tr, err := regexp.Compile(`^logline (?P\u003cseqn\u003e\\d{7})\\s*`)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tseqnIndex := r.SubexpIndex(\"seqn\")\n\t\t\t\tfor _, line := range outputLines {\n\t\t\t\t\tif matches := r.FindStringSubmatch(line); len(matches) \u003e seqnIndex {\n\t\t\t\t\t\tseqnString := matches[seqnIndex]\n\t\t\t\t\t\ti, err := strconv.Atoi(seqnString)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tif prevSeqn \u003e 0 {\n\t\t\t\t\t\t\tExpect(i).To(Equal(prevSeqn+1), fmt.Sprintf(\"log line seq number should match previous+1: previous %d, current: %d.\\nprevLine: %s\\nline: %s\", prevSeqn, i, line, prevLine))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSeqn = i\n\t\t\t\t\t\tprevLine = line\n\t\t\t\t\t\tmatchingLines = matchingLines + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tExpect(matchingLines).To(BeNumerically(\"\u003e\", 1000))\n\t\t\t})\n\n\t\t\tAfterEach(func() {\n\t\t\t\tif CurrentSpecReport().Failed() {\n\t\t\t\t\tif vmi != nil {\n\t\t\t\t\t\tvirtlauncherPod, err := libpod.GetPodByVirtualMachineInstance(vmi, testsuite.GetTestNamespace(vmi))\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\tartifactsDir, _ := os.LookupEnv(\"ARTIFACTS\")\n\t\t\t\t\t\t\toutputString, err := exec.ExecuteCommandOnPod(virtlauncherPod, \"guest-console-log\", []string{\"/bin/bash\", \"-c\", \"/bin/tail -v -n +1 \" + fmt.Sprintf(\"/var/run/kubevirt-private/%v/virt-serial*-log*\", vmi.UID)})\n\t\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\t\tlpath := filepath.Join(artifactsDir, fmt.Sprintf(\"serial_logs_content_%v.txt\", vmi.UID))\n\t\t\t\t\t\t\t\t_, _ = fmt.Fprintf(GinkgoWriter, \"Serial console log failed, serial console logs dump from virt-launcher pod collected at file at %s\\n\", lpath)\n\t\t\t\t\t\t\t\t_ = os.WriteFile(lpath, []byte(outputString), 0644)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t})\n\n\t})\n})\n\nfunc generateHugeLogData(vmi *v1.VirtualMachineInstance, mb int) {\n\tBy(\"Obtaining the serial console, logging in\")\n\tExpect(console.LoginToCirros(vmi)).To(Succeed())\n\tExpect(console.SafeExpectBatch(vmi, []expect.Batcher{\n\t\t\u0026expect.BSnd{S: \"echo \" + testString + \"\\n\"},\n\t\t\u0026expect.BExp{R: testString},\n\t}, 240)).To(Succeed())\n\n\tBy(fmt.Sprintf(\"Generating about %dMB of data\", mb))\n\t// (128 bytes/line) * (8 * 1024 * N) = N MB\n\t// serial is expected to be at 115200 bps -\u003e 1MB takes 73 seconds\n\tstartn := fmt.Sprintf(\"%07d\", 1)\n\tendn := fmt.Sprintf(\"%07d\", 8*1024*mb)\n\tExpect(console.SafeExpectBatch(vmi, []expect.Batcher{\n\t\t\u0026expect.BSnd{S: \"for num in $(seq -w \" + startn + \" \" + endn + \"); do echo \\\"logline ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num} ${num}\\\"; done\" + \"\\n\"},\n\t\t\u0026expect.BExp{R: \"logline \" + endn},\n\t}, 240)).To(Succeed())\n}\n\nfunc getConsoleLogs(virtlauncherPod *k8sv1.Pod) (string, error) {\n\tlogsRaw, err := kubevirt.Client().CoreV1().\n\t\tPods(virtlauncherPod.Namespace).\n\t\tGetLogs(virtlauncherPod.Name, \u0026k8sv1.PodLogOptions{\n\t\t\tContainer: \"guest-console-log\",\n\t\t}).\n\t\tDoRaw(context.Background())\n\treturn strings.ReplaceAll(string(logsRaw), \"\\r\\n\", \"\\n\"), err\n}\n"}
